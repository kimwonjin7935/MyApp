<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>whereIsMyCar (웹버전)</title>
<style>
  body, html {
    margin:0; padding:0; height:100vh; overflow:hidden;
    display:flex; flex-direction: column;
    font-family: Arial, sans-serif;
  }
  #buttons {
    padding: 10px;
    background: #333;
    display: flex;
    gap: 10px;
  }
  button {
    flex: 1;
    padding: 10px;
    color: white;
    background: #007bff;
    border: none;
    border-radius: 4px;
    font-size: 16px;
  }
  button:hover { background: #0056b3; }

  /* 스크롤 영역 */
  #container {
    position: relative;
    flex-grow: 1;
    background-color: #ccc;
    overflow: auto;            /* 확대 후 스크롤 */
    touch-action: none;        /* 핀치 제스처 직접 처리 */
  }

  /* 확대/축소 대상 래퍼 (배경과 전경을 같이 담음) */
  #stage {
    position: relative;
    width: 100%;              /* 논리 크기(스케일 1 기준) */
    height: 100%;
    transform-origin: 0 0;
    will-change: transform;
  }

  #background {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: contain;
    user-select: none;
    pointer-events: none;
  }

  #foreground {
    position: absolute;
    width: 150px;
    height: 150px;
    cursor: grab;
    user-select: none;
    display: none;
    touch-action: none; /* 전경 위 핀치 감지용 */
  }

  #fg-resize-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    background: rgba(0,0,0,0.5);
    right: 0; bottom: 0;
    cursor: se-resize;
    display: none;
  }

  #zoomHud {
    position: fixed;
    right: 10px;
    bottom: 10px;
    background: rgba(0,0,0,.55);
    color: #fff;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 13px;
    z-index: 10;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="buttons">
  <button id="btnBg">배경사진등록및변경</button>
  <button id="btnFg">전경사진등록및변경</button>
</div>

<div id="container">
  <div id="stage">
    <img id="background" src="" alt="배경이미지" />
    <img id="foreground" src="" alt="전경이미지" draggable="false" />
    <div id="fg-resize-handle"></div>
  </div>
</div>

<div id="zoomHud" aria-hidden="true">100%</div>

<input type="file" id="inputBg" accept="image/*" style="display:none;" />
<input type="file" id="inputFg" accept="image/*" style="display:none;" />

<script>
const btnBg = document.getElementById('btnBg');
const btnFg = document.getElementById('btnFg');
const inputBg = document.getElementById('inputBg');
const inputFg = document.getElementById('inputFg');
const bg = document.getElementById('background');
const fg = document.getElementById('foreground');
const fgHandle = document.getElementById('fg-resize-handle');
const container = document.getElementById('container');
const stage = document.getElementById('stage');
const zoomHud = document.getElementById('zoomHud');

/* =============== 스케일/좌표 시스템 =============== */
let baseW = 0, baseH = 0;   // 논리 크기(스케일 1 기준)
let scale = 1;              // 배경+전경 공통 배율
const MIN_SCALE = 0.25;
const MAX_SCALE = 8;
const SCALE_STEP = 1.1;

const FG_MIN = 20;          // 전경 최소 논리 크기
// 전경 상태(논리 좌표/크기)
const fgState = { x: 0, y: 0, w: 150, h: 150, visible: false };

function clamp(v, min, max){ return Math.min(Math.max(v, min), max); }

function updateBaseSize(){
  baseW = container.clientWidth;
  baseH = container.clientHeight;
}

function syncFgVisual(){
  if (!fgState.visible) return;
  fg.style.display = 'block';
  fgHandle.style.display = 'block';
  fg.style.left   = (fgState.x * scale) + 'px';
  fg.style.top    = (fgState.y * scale) + 'px';
  fg.style.width  = (fgState.w * scale) + 'px';
  fg.style.height = (fgState.h * scale) + 'px';
}

/* ===== 배경 확대/축소: 배경+전경 동시에 같은 비율 ===== */
function applyStageScale(next, anchor /* {clientX, clientY} | null */){
  next = clamp(next, MIN_SCALE, MAX_SCALE);
  const prev = scale;

  if (anchor) {
    const rect = container.getBoundingClientRect();
    const sx = container.scrollLeft + (anchor.clientX - rect.left);
    const sy = container.scrollTop  + (anchor.clientY - rect.top);

    scale = next;
    stage.style.width  = (baseW * scale) + 'px';
    stage.style.height = (baseH * scale) + 'px';
    syncFgVisual();

    const ratio = scale / prev;
    container.scrollLeft = sx * ratio - (anchor.clientX - rect.left);
    container.scrollTop  = sy * ratio - (anchor.clientY - rect.top);
  } else {
    scale = next;
    stage.style.width  = (baseW * scale) + 'px';
    stage.style.height = (baseH * scale) + 'px';
    syncFgVisual();
  }

  zoomHud.textContent = Math.round(scale * 100) + '%';
  localStorage.setItem('zoom-scale', String(scale));
}

/* ===== 전경만 확대/축소 (휠/핀치) ===== */
function screenToStageLogical(clientX, clientY){
  const rect = container.getBoundingClientRect();
  const sx = container.scrollLeft + (clientX - rect.left);
  const sy = container.scrollTop  + (clientY - rect.top);
  return { lx: sx / scale, ly: sy / scale }; // 논리 좌표로
}

/* 앵커(논리 좌표) 기준으로 전경 크기만 배율 변경 */
function resizeForegroundByFactor(factor, anchorLogical){
  if (!fgState.visible) return;

  let newW = clamp(fgState.w * factor, FG_MIN, baseW);
  let newH = clamp(fgState.h * factor, FG_MIN, baseH);

  // 앵커를 기준으로 위치 조정 (앵커가 fg 내부 어디에 있는지 비율로 계산)
  const ax = clamp(anchorLogical.lx, fgState.x, fgState.x + fgState.w);
  const ay = clamp(anchorLogical.ly, fgState.y, fgState.y + fgState.h);
  const relX = (ax - fgState.x) / fgState.w;
  const relY = (ay - fgState.y) / fgState.h;

  let newX = ax - relX * newW;
  let newY = ay - relY * newH;

  // 경계 내로 보정
  newX = clamp(newX, 0, Math.max(0, baseW - newW));
  newY = clamp(newY, 0, Math.max(0, baseH - newH));

  fgState.w = newW;
  fgState.h = newH;
  fgState.x = newX;
  fgState.y = newY;

  syncFgVisual();
  saveFgState();
}

/* =============== 저장/복원 =============== */
function saveImage(id, imgElement) {
  if (!imgElement.naturalWidth) return;
  const canvas = document.createElement('canvas');
  canvas.width = imgElement.naturalWidth;
  canvas.height = imgElement.naturalHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(imgElement, 0, 0);
  const dataURL = canvas.toDataURL('image/png');
  localStorage.setItem(id, dataURL);
}

function loadImage(id, imgElement) {
  const dataURL = localStorage.getItem(id);
  if(dataURL){
    imgElement.src = dataURL;
    imgElement.style.display = 'block';
  }
}

function saveFgState(){
  localStorage.setItem('fg-x', String(fgState.x));
  localStorage.setItem('fg-y', String(fgState.y));
  localStorage.setItem('fg-w', String(fgState.w));
  localStorage.setItem('fg-h', String(fgState.h));
  localStorage.setItem('fg-visible', fgState.visible ? '1' : '0');
}

function loadFgState(){
  const vis = localStorage.getItem('fg-visible') === '1';
  const x = parseFloat(localStorage.getItem('fg-x') || '0');
  const y = parseFloat(localStorage.getItem('fg-y') || '0');
  const w = parseFloat(localStorage.getItem('fg-w') || '150');
  const h = parseFloat(localStorage.getItem('fg-h') || '150');

  fgState.visible = vis;
  fgState.x = isNaN(x) ? 0 : x;
  fgState.y = isNaN(y) ? 0 : y;
  fgState.w = isNaN(w) ? 150 : w;
  fgState.h = isNaN(h) ? 150 : h;

  if (fgState.visible) {
    fg.style.display = 'block';
    fgHandle.style.display = 'block';
    syncFgVisual();
  }
}

/* =============== 버튼/파일 입력 =============== */
btnBg.onclick = () => inputBg.click();
btnFg.onclick = () => inputFg.click();

inputBg.onchange = (e) => {
  const file = e.target.files[0];
  if(file){
    const url = URL.createObjectURL(file);
    bg.src = url;
    bg.onload = () => {
      saveImage('bg', bg);
      updateBaseSize();
      applyStageScale(scale, null);
    };
  }
};

inputFg.onchange = (e) => {
  const file = e.target.files[0];
  if(file){
    const url = URL.createObjectURL(file);
    fg.src = url;
    fg.onload = () => saveImage('fg', fg);
    // 중앙 배치(논리)
    fgState.w = 150; fgState.h = 150;
    fgState.x = Math.max(0, (baseW - fgState.w)/2);
    fgState.y = Math.max(0, (baseH - fgState.h)/2);
    fgState.visible = true;
    saveFgState();
    syncFgVisual();
  }
};

/* =============== 전경 드래그(배율 고려) =============== */
let dragging = false, dragDX=0, dragDY=0;

function startDrag(e){
  if (!fgState.visible) return;
  dragging = true;
  const p = e.touches ? e.touches[0] : e;
  const fgRect = fg.getBoundingClientRect();
  dragDX = p.clientX - fgRect.left;
  dragDY = p.clientY - fgRect.top;
  fg.style.cursor = 'grabbing';
}

function dragMove(e){
  if(!dragging) return;
  e.preventDefault();
  const p = e.touches ? e.touches[0] : e;
  const sRect = stage.getBoundingClientRect();

  const xScreen = p.clientX - sRect.left - dragDX + container.scrollLeft;
  const yScreen = p.clientY - sRect.top  - dragDY + container.scrollTop;

  let nx = xScreen / scale;
  let ny = yScreen / scale;

  nx = clamp(nx, 0, baseW - fgState.w);
  ny = clamp(ny, 0, baseH - fgState.h);

  fgState.x = nx;
  fgState.y = ny;
  syncFgVisual();
  saveFgState();
}

function stopDrag(){ dragging=false; fg.style.cursor='grab'; }

fg.addEventListener('mousedown', startDrag);
fg.addEventListener('touchstart', startDrag, {passive:false});
window.addEventListener('mousemove', dragMove, {passive:false});
window.addEventListener('touchmove', dragMove, {passive:false});
window.addEventListener('mouseup', stopDrag);
window.addEventListener('touchend', stopDrag);

/* =============== 전경 리사이즈(핸들, 배율 고려) =============== */
let resizing = false;

function startResize(e){
  e.stopPropagation();
  resizing = true;
}

function resizeMove(e){
  if(!resizing) return;
  e.preventDefault();
  const p = e.touches ? e.touches[0] : e;
  const fgRect = fg.getBoundingClientRect();

  let newW = Math.max(FG_MIN, (p.clientX - fgRect.left) / scale);
  let newH = Math.max(FG_MIN, (p.clientY - fgRect.top)  / scale);

  newW = Math.min(newW, baseW - fgState.x);
  newH = Math.min(newH, baseH - fgState.y);

  fgState.w = newW;
  fgState.h = newH;

  syncFgVisual();
  saveFgState();
}

function stopResize(){ resizing=false; }

fgHandle.addEventListener('mousedown', startResize);
fgHandle.addEventListener('touchstart', startResize, {passive:false});
window.addEventListener('mousemove', resizeMove, {passive:false});
window.addEventListener('touchmove', resizeMove, {passive:false});
window.addEventListener('mouseup', stopResize);
window.addEventListener('touchend', stopResize);

/* =============== 확대/축소 입력 처리 =============== */
/* 1) 컨테이너에서 Ctrl+휠 = 배경(=전체) 확대/축소 */
container.addEventListener('wheel', (e) => {
  // 전경 위에서 Ctrl+휠이면 전경만 확대 (아래 fg 휠 핸들러에서 처리)
  if (e.ctrlKey && fgState.visible && e.target === fg) return;

  if (!e.ctrlKey) return;  // 일반 스크롤 허용
  e.preventDefault();
  const next = scale * (e.deltaY > 0 ? 1 / SCALE_STEP : SCALE_STEP);
  applyStageScale(next, { clientX: e.clientX, clientY: e.clientY });
}, { passive:false });

/* 2) 전경 위에서 Ctrl+휠 = 전경만 확대/축소 */
fg.addEventListener('wheel', (e) => {
  if (!e.ctrlKey) return;
  e.preventDefault();
  const factor = (e.deltaY > 0) ? (1 / SCALE_STEP) : SCALE_STEP;
  const anchor = screenToStageLogical(e.clientX, e.clientY);
  resizeForegroundByFactor(factor, anchor);
}, { passive:false });

/* 3) 핀치 제스처: 컨테이너에서 두 손가락 = 전체 확대/축소 */
let containerPointers = new Map();
let lastPinchDist = null;

container.addEventListener('pointerdown', (e) => {
  container.setPointerCapture(e.pointerId);
  containerPointers.set(e.pointerId, { x: e.clientX, y: e.clientY, target: e.target });
});

container.addEventListener('pointermove', (e) => {
  if (!containerPointers.has(e.pointerId)) return;
  containerPointers.set(e.pointerId, { x: e.clientX, y: e.clientY, target: e.target });

  if (containerPointers.size === 2) {
    e.preventDefault();
    const pts = Array.from(containerPointers.values());
    const [p0, p1] = pts;

    const dx = p0.x - p1.x;
    const dy = p0.y - p1.y;
    const dist = Math.hypot(dx, dy);
    const cx = (p0.x + p1.x) / 2;
    const cy = (p0.y + p1.y) / 2;

    // 전경 위에서 발생한 두 손가락이라면 전경만 확대/축소
    const bothOnFg = pts.every(p => p.target === fg);
    if (bothOnFg && fgState.visible) {
      if (lastPinchDist != null) {
        const ratio = dist / lastPinchDist;
        resizeForegroundByFactor(ratio, screenToStageLogical(cx, cy));
      }
      lastPinchDist = dist;
      return;
    }

    // 그 외는 배경+전경 전체 확대/축소
    if (lastPinchDist != null) {
      const ratio = dist / lastPinchDist;
      applyStageScale(scale * ratio, { clientX: cx, clientY: cy });
    }
    lastPinchDist = dist;
  }
}, { passive:false });

['pointerup','pointercancel','pointerleave'].forEach(type => {
  container.addEventListener(type, (e) => {
    containerPointers.delete(e.pointerId);
    if (containerPointers.size < 2) lastPinchDist = null;
  });
});

/* 4) 단축키: Ctrl + (+/-/0) = 전체 확대/축소/리셋 */
window.addEventListener('keydown', (e) => {
  if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
    e.preventDefault();
    applyStageScale(scale * SCALE_STEP, null);
  } else if (e.ctrlKey && (e.key === '-' || e.key === '_')) {
    e.preventDefault();
    applyStageScale(scale / SCALE_STEP, null);
  } else if (e.ctrlKey && (e.key === '0')) {
    e.preventDefault();
    applyStageScale(1, null);
    container.scrollTo({ left: 0, top: 0, behavior: 'instant' });
  }
});

/* =============== 초기화/복원 =============== */
function restoreZoom(){
  const saved = parseFloat(localStorage.getItem('zoom-scale') || '1');
  applyStageScale(isNaN(saved) || saved <= 0 ? 1 : saved, null);
}

window.addEventListener('load', () => {
  updateBaseSize();
  restoreZoom();

  loadImage('bg', bg);
  loadImage('fg', fg);
  loadFgState();

  stage.style.width  = (baseW * scale) + 'px';
  stage.style.height = (baseH * scale) + 'px';
  syncFgVisual();
});

window.addEventListener('resize', () => {
  const cur = scale;
  updateBaseSize();
  applyStageScale(cur, null);
});
</script>
</body>
</html>
