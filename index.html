<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>whereIsMyCar (웹버전)</title>
<style>
  body, html {
    margin:0; padding:0; height:100vh; overflow:hidden;
    display:flex; flex-direction: column;
    font-family: Arial, sans-serif;
  }
  #buttons {
    padding: 10px;
    background: #333;
    display: flex;
    gap: 10px;
  }
  button {
    flex: 1;
    padding: 10px;
    color: white;
    background: #007bff;
    border: none;
    border-radius: 4px;
    font-size: 16px;
  }
  button:hover { background: #0056b3; }

  /* 스크롤 영역 */
  #container {
    position: relative;
    flex-grow: 1;
    background-color: #ccc;
    overflow: auto;            /* 확대 후 스크롤 */
    touch-action: none;        /* 커스텀 핀치 제스처 처리 */
  }

  /* 확대/축소 대상(배경+전경을 모두 포함하는 래퍼) */
  #stage {
    position: relative;
    width: 100%;              /* 초기 크기 = 컨테이너 크기 */
    height: 100%;
    transform-origin: 0 0;    /* 좌상단 기준 스케일 */
    will-change: transform;
  }

  /* 배경/전경은 stage 내부로 이동 */
  #background {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: contain;
    user-select: none;
    pointer-events: none;     /* 배경은 포인터 통과 */
  }
  #foreground {
    position: absolute;
    width: 150px;
    height: 150px;
    cursor: grab;
    user-select: none;
    display: none;
    touch-action: none;
  }
  #fg-resize-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    background: rgba(0,0,0,0.5);
    right: 0; bottom: 0;
    cursor: se-resize;
    display: none;
  }

  /* 우측 하단에 배율 표시 (옵션) */
  #zoomHud {
    position: fixed;
    right: 10px;
    bottom: 10px;
    background: rgba(0,0,0,.55);
    color: #fff;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 13px;
    z-index: 10;
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="buttons">
  <button id="btnBg">배경사진등록및변경</button>
  <button id="btnFg">전경사진등록및변경</button>
</div>

<div id="container">
  <!-- 확대/축소 대상 래퍼 -->
  <div id="stage">
    <img id="background" src="" alt="배경이미지" />
    <img id="foreground" src="" alt="전경이미지" draggable="false" />
    <div id="fg-resize-handle"></div>
  </div>
</div>

<div id="zoomHud" aria-hidden="true">100%</div>

<input type="file" id="inputBg" accept="image/*" style="display:none;" />
<input type="file" id="inputFg" accept="image/*" style="display:none;" />

<script>
const btnBg = document.getElementById('btnBg');
const btnFg = document.getElementById('btnFg');
const inputBg = document.getElementById('inputBg');
const inputFg = document.getElementById('inputFg');
const bg = document.getElementById('background');
const fg = document.getElementById('foreground');
const fgHandle = document.getElementById('fg-resize-handle');
const container = document.getElementById('container');
const stage = document.getElementById('stage');
const zoomHud = document.getElementById('zoomHud');

/* ===================== 확대/축소 공통 ===================== */
let baseWidth = 0;    // stage의 기준 너비
let baseHeight = 0;   // stage의 기준 높이
let scale = 1;        // 현재 배율
const MIN_SCALE = 0.25;
const MAX_SCALE = 8;
const SCALE_STEP = 1.1;

function updateStageSize() {
  // 컨테이너에 맞게 기본 크기를 설정 (배경 로드 전·후, 리사이즈 시 호출)
  // 배경의 비율을 고려하려면 object-fit: contain 상태에서 컨테이너 크기를 기준으로 두는 게 자연스러움
  baseWidth  = container.clientWidth;
  baseHeight = container.clientHeight;

  applyScale(scale, null);
}

function applyScale(nextScale, anchor /* {clientX, clientY} or null */) {
  // 스케일 제한
  nextScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, nextScale));

  if (anchor) {
    // 스케일 중심(anchor) 유지: 스크롤 위치 보정
    const rect = container.getBoundingClientRect();
    const scrollLeft = container.scrollLeft;
    const scrollTop  = container.scrollTop;
    const ax = anchor.clientX - rect.left + scrollLeft;
    const ay = anchor.clientY - rect.top  + scrollTop;

    const prevScale = scale;
    scale = nextScale;

    const nx = ax * (scale / prevScale);
    const ny = ay * (scale / prevScale);

    // stage의 실제 박스 크기도 키워서 스크롤바가 실제로 생기도록 함
    stage.style.width  = (baseWidth  * scale) + 'px';
    stage.style.height = (baseHeight * scale) + 'px';
    stage.style.transform = `scale(${1})`; // transform 대신 실제 크기 변경을 우선
    // 위에서 width/height로 실제 크기를 바꾸기 때문에 transform은 1로 둡니다.
    // (transform 스케일만 쓸 경우 스크롤 영역이 변하지 않는 문제가 있음)

    // 앵커를 고정하려면 스크롤을 재계산
    container.scrollLeft = nx - (anchor.clientX - rect.left);
    container.scrollTop  = ny - (anchor.clientY - rect.top);
  } else {
    scale = nextScale;
    stage.style.width  = (baseWidth  * scale) + 'px';
    stage.style.height = (baseHeight * scale) + 'px';
    stage.style.transform = `scale(${1})`;
  }

  zoomHud.textContent = Math.round(scale * 100) + '%';
  localStorage.setItem('zoom-scale', String(scale));
}

/* 마우스 휠(CTRL+휠 또는 트랙패드 핀치) */
container.addEventListener('wheel', (e) => {
  // Ctrl 키가 눌린 경우만 확대/축소 (일반 스크롤은 그대로)
  if (!e.ctrlKey) return;
  e.preventDefault();

  const delta = e.deltaY;
  const factor = delta > 0 ? (1 / SCALE_STEP) : SCALE_STEP;
  const next = scale * factor;
  applyScale(next, { clientX: e.clientX, clientY: e.clientY });
}, { passive: false });

/* 터치 핀치 확대/축소 (PointerEvent 기반) */
let pointers = new Map();
let lastPinchDistance = null;

container.addEventListener('pointerdown', (e) => {
  container.setPointerCapture(e.pointerId);
  pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
});

container.addEventListener('pointermove', (e) => {
  if (!pointers.has(e.pointerId)) return;
  pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

  if (pointers.size === 2) {
    e.preventDefault();
    const pts = Array.from(pointers.values());
    const dx = pts[0].x - pts[1].x;
    const dy = pts[0].y - pts[1].y;
    const dist = Math.hypot(dx, dy);

    const cx = (pts[0].x + pts[1].x) / 2;
    const cy = (pts[0].y + pts[1].y) / 2;

    if (lastPinchDistance != null) {
      const ratio = dist / lastPinchDistance;
      let next = scale * ratio;
      applyScale(next, { clientX: cx, clientY: cy });
    }
    lastPinchDistance = dist;
  }
}, { passive: false });

['pointerup','pointercancel','pointerleave'].forEach(type => {
  container.addEventListener(type, (e) => {
    pointers.delete(e.pointerId);
    if (pointers.size < 2) {
      lastPinchDistance = null;
    }
  });
});

/* 키보드 단축키: Ctrl + (+/-/0) */
window.addEventListener('keydown', (e) => {
  if (e.ctrlKey && (e.key === '+' || e.key === '=')) {
    e.preventDefault();
    applyScale(scale * SCALE_STEP, null);
  } else if (e.ctrlKey && (e.key === '-' || e.key === '_')) {
    e.preventDefault();
    applyScale(scale / SCALE_STEP, null);
  } else if (e.ctrlKey && (e.key === '0')) {
    e.preventDefault();
    applyScale(1, null);
    container.scrollTo({ left: 0, top: 0, behavior: 'instant' });
  }
});

/* ===================== 저장/복원 ===================== */
function saveImage(id, imgElement) {
  if (!imgElement.naturalWidth) return;
  const canvas = document.createElement('canvas');
  canvas.width = imgElement.naturalWidth;
  canvas.height = imgElement.naturalHeight;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(imgElement, 0, 0);
  const dataURL = canvas.toDataURL('image/png');
  localStorage.setItem(id, dataURL);
}

function loadImage(id, imgElement) {
  const dataURL = localStorage.getItem(id);
  if(dataURL){
    imgElement.src = dataURL;
    imgElement.style.display = 'block';
  }
}

function saveForegroundState() {
  localStorage.setItem('fg-left', fg.style.left);
  localStorage.setItem('fg-top', fg.style.top);
  localStorage.setItem('fg-width', fg.style.width);
  localStorage.setItem('fg-height', fg.style.height);
}

function loadForegroundState() {
  const left = localStorage.getItem('fg-left');
  const top = localStorage.getItem('fg-top');
  const width = localStorage.getItem('fg-width');
  const height = localStorage.getItem('fg-height');
  if(left && top && width && height){
    fg.style.left = left;
    fg.style.top = top;
    fg.style.width = width;
    fg.style.height = height;
    // 핸들은 fg 내부 right/bottom:0 스타일이라 자동 위치
  }
}

/* ===================== 버튼 ===================== */
btnBg.onclick = () => inputBg.click();
btnFg.onclick = () => inputFg.click();

inputBg.onchange = (e) => {
  const file = e.target.files[0];
  if(file){
    const url = URL.createObjectURL(file);
    bg.src = url;
    bg.onload = () => {
      saveImage('bg', bg);
      // 배경 로드 후 스테이지 기본 크기 재계산
      updateStageSize();
    };
  }
};

inputFg.onchange = (e) => {
  const file = e.target.files[0];
  if(file){
    const url = URL.createObjectURL(file);
    fg.src = url;
    fg.style.display = 'block';
    fgHandle.style.display = 'block';

    // stage 기준 가운데 배치
    const sRect = stage.getBoundingClientRect();
    const initLeft = Math.max(0, (stage.clientWidth  - 150) / 2);
    const initTop  = Math.max(0, (stage.clientHeight - 150) / 2);
    fg.style.left = initLeft + 'px';
    fg.style.top  = initTop  + 'px';

    fg.onload = () => {
      saveImage('fg', fg);
      saveForegroundState();
    };
  }
};

/* ===================== 전경 드래그 ===================== */
let isDragging = false, dragOffsetX=0, dragOffsetY=0;

function startDrag(e){
  isDragging = true;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  // stage 내 좌표로 변환 (stage는 실제 픽셀로 커졌으니 그대로 계산)
  dragOffsetX = clientX - (fg.getBoundingClientRect().left);
  dragOffsetY = clientY - (fg.getBoundingClientRect().top);
  fg.style.cursor = 'grabbing';
}

function dragMove(e){
  if(!isDragging) return;
  e.preventDefault();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  // stage의 스크롤 포함 좌표로 변환
  const sRect = stage.getBoundingClientRect();
  const cRect = container.getBoundingClientRect();

  // 드래그 목표 좌표(컨테이너 스크롤 포함)
  const xInStage = (clientX - sRect.left) + container.scrollLeft - dragOffsetX + (fg.offsetLeft - (fg.getBoundingClientRect().left - sRect.left));
  const yInStage = (clientY - sRect.top ) + container.scrollTop  - dragOffsetY + (fg.offsetTop  - (fg.getBoundingClientRect().top  - sRect.top));

  // 경계 제한
  const maxX = stage.clientWidth  - fg.clientWidth;
  const maxY = stage.clientHeight - fg.clientHeight;

  const nx = Math.min(Math.max(0, xInStage), maxX);
  const ny = Math.min(Math.max(0, yInStage), maxY);

  fg.style.left = nx + 'px';
  fg.style.top  = ny + 'px';

  saveForegroundState();
}

function stopDrag(){ isDragging=false; fg.style.cursor='grab'; }

fg.addEventListener('mousedown', startDrag);
fg.addEventListener('touchstart', startDrag, {passive:false});

window.addEventListener('mousemove', dragMove, {passive:false});
window.addEventListener('touchmove', dragMove, {passive:false});

window.addEventListener('mouseup', stopDrag);
window.addEventListener('touchend', stopDrag);

/* ===================== 전경 크기 조절 ===================== */
let isResizing = false;

function startResize(e){
  e.stopPropagation();
  isResizing = true;
}

function resizeMove(e){
  if(!isResizing) return;
  e.preventDefault();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;

  const sRect = stage.getBoundingClientRect();
  const fgRect = fg.getBoundingClientRect();

  let newWidth  = (clientX - fgRect.left);
  let newHeight = (clientY - fgRect.top);

  newWidth  = Math.max(30, newWidth);
  newHeight = Math.max(30, newHeight);

  // stage 경계 내에서만
  const rightEdge = parseFloat(fg.style.left || '0') + newWidth;
  const bottomEdge = parseFloat(fg.style.top || '0') + newHeight;
  newWidth  = Math.min(newWidth,  stage.clientWidth  - parseFloat(fg.style.left || '0'));
  newHeight = Math.min(newHeight, stage.clientHeight - parseFloat(fg.style.top  || '0'));

  fg.style.width  = newWidth + 'px';
  fg.style.height = newHeight + 'px';

  saveForegroundState();
}

function stopResize(){ isResizing=false; }

fgHandle.addEventListener('mousedown', startResize);
fgHandle.addEventListener('touchstart', startResize, {passive:false});

window.addEventListener('mousemove', resizeMove, {passive:false});
window.addEventListener('touchmove', resizeMove, {passive:false});

window.addEventListener('mouseup', stopResize);
window.addEventListener('touchend', stopResize);

/* ===================== 초기화 & 복원 ===================== */
function restoreZoom() {
  const saved = parseFloat(localStorage.getItem('zoom-scale') || '1');
  if (!isNaN(saved) && saved > 0) {
    applyScale(saved, null);
  } else {
    applyScale(1, null);
  }
}

// 페이지 로드 시
window.addEventListener('load', () => {
  updateStageSize();        // 기본 크기 확정
  restoreZoom();            // 배율 복원

  loadImage('bg', bg);
  loadImage('fg', fg);

  if(fg.src){
    fg.style.display = 'block';
    fgHandle.style.display = 'block';
    loadForegroundState();
  }
});

// 창 크기 변경 시: 기본 크기 재계산 후 현재 배율 유지
window.addEventListener('resize', () => {
  const currentScale = scale;
  updateStageSize();
  applyScale(currentScale, null);
});
</script>
</body>
</html>
