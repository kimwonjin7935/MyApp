<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>whereIsMyCar (웹버전)</title>
<style>
  body, html { margin:0; padding:0; height:100vh; overflow:hidden;
    display:flex; flex-direction: column; font-family: Arial, sans-serif;}
  /* 상단 바: 오른쪽 정렬을 위해 버튼에 auto margin 사용 */
  #buttons { padding: 10px; background: #333; display: flex; gap: 10px; align-items:center;}
  button { padding:10px 12px; color:#fff; background:#007bff; border:none;
    border-radius:4px; font-size:16px; cursor:pointer; }
  button:hover { background:#0056b3;}
  /* 오른쪽 끝으로 밀기 */
  #btnFull { margin-left: auto; background:#28a745; }
  #btnFull:hover { background:#1e7e34; }

  #container { position:relative; flex-grow:1; background:#ccc;
    overflow:auto; touch-action:none;}
  #stage { position:relative; width:100%; height:100%; }
  #background { position:absolute; inset:0; width:100%; height:100%;
    object-fit:contain; user-select:none; pointer-events:none;}
  #foreground { position:absolute; width:150px; height:150px; cursor:grab;
    user-select:none; display:none; touch-action:none;}
  #fg-resize-handle { position:absolute; width:15px; height:15px;
    background:rgba(0,0,0,.5); right:0; bottom:0; cursor:se-resize; display:none;}
  #zoomHud { position:fixed; right:10px; bottom:10px; background:rgba(0,0,0,.55);
    color:#fff; padding:6px 10px; border-radius:6px; font-size:13px; z-index:10;}
</style>
</head>
<body>
<div id="buttons">
  <button id="btnBg">배경사진등록</button>
  <button id="btnFg">전경사진등록</button>
  <!-- 추가: 전체화면(100%) 버튼 -->
  <button id="btnFull">전체화면</button>
</div>
<div id="container">
  <div id="stage">
    <img id="background" src="" alt="배경이미지" />
    <img id="foreground" src="" alt="전경이미지" draggable="false" />
    <div id="fg-resize-handle"></div>
  </div>
</div>
<div id="zoomHud">100%</div>
<input type="file" id="inputBg" accept="image/*" style="display:none;" />
<input type="file" id="inputFg" accept="image/*" style="display:none;" />
<script>
/* ===== 요소 ===== */
const container=document.getElementById('container');
const stage=document.getElementById('stage');
const bg=document.getElementById('background');
const fg=document.getElementById('foreground');
const fgHandle=document.getElementById('fg-resize-handle');
const zoomHud=document.getElementById('zoomHud');
const btnBg=document.getElementById('btnBg');
const btnFg=document.getElementById('btnFg');
const btnFull=document.getElementById('btnFull'); // 추가
const inputBg=document.getElementById('inputBg');
const inputFg=document.getElementById('inputFg');
/* ===== 상태 ===== */
let baseW=0, baseH=0;
let scale=1;
const STEP=1.1, MIN_SCALE=0.25, MAX_SCALE=8;
const clamp=(v,a,b)=>Math.min(Math.max(v,a),b);
const fgState={x:0,y:0,w:150,h:150,visible:false};
/* ===== 저장/복원 ===== */
function saveImageToStorage(key,img){
  if(!img.src) return;
  // dataURL로 저장
  const c=document.createElement('canvas');
  c.width=img.naturalWidth; c.height=img.naturalHeight;
  const ctx=c.getContext('2d'); ctx.drawImage(img,0,0);
  localStorage.setItem(key,c.toDataURL('image/png'));
}
function restoreImageFromStorage(key,img,cb){
  const data=localStorage.getItem(key);
  if(data){ img.src=data; img.onload=()=>cb&&cb(); }
}
function saveState(){
  localStorage.setItem('scale',scale);
  localStorage.setItem('fgState',JSON.stringify(fgState));
  localStorage.setItem('scrollX',container.scrollLeft);
  localStorage.setItem('scrollY',container.scrollTop);
  // 이미지 저장
  saveImageToStorage('bgImage',bg);
  if(fgState.visible) saveImageToStorage('fgImage',fg);
}
function restoreState(){
  const savedScale=parseFloat(localStorage.getItem('scale'));
  if(savedScale) scale=savedScale;
  const savedFg=localStorage.getItem('fgState');
  if(savedFg){ Object.assign(fgState,JSON.parse(savedFg)); }
  const sx=parseInt(localStorage.getItem('scrollX')||'0');
  const sy=parseInt(localStorage.getItem('scrollY')||'0');
  setTimeout(()=>{ container.scrollLeft=sx; container.scrollTop=sy; },50);
  restoreImageFromStorage('bgImage',bg,()=>{ computeBaseSize(); applyStageSize(); });
  restoreImageFromStorage('fgImage',fg,()=>{ if(fgState.visible) syncFgVisual(); });
}
/* ===== 유틸 ===== */
function computeBaseSize(){
  const cw=container.clientWidth,ch=container.clientHeight;
  if(bg.naturalWidth&&bg.naturalHeight){
    const s=Math.min(cw/bg.naturalWidth,ch/bg.naturalHeight);
    baseW=bg.naturalWidth*s; baseH=bg.naturalHeight*s;
  } else { baseW=cw;baseH=ch; }
}
function applyStageSize(){ stage.style.width=(baseW*scale)+'px';
  stage.style.height=(baseH*scale)+'px'; syncFgVisual(); }
function syncFgVisual(){
  if(!fgState.visible) return;
  fg.style.display='block'; fgHandle.style.display='block';
  fg.style.left=(fgState.x*scale)+'px'; fg.style.top=(fgState.y*scale)+'px';
  fg.style.width=(fgState.w*scale)+'px'; fg.style.height=(fgState.h*scale)+'px';
}
function screenToLogical(x,y){
  const r=container.getBoundingClientRect();
  return {lx:(container.scrollLeft+(x-r.left))/scale,
          ly:(container.scrollTop+(y-r.top))/scale};
}
function pointInFg(x,y){
  const r=fg.getBoundingClientRect();
  return x>=r.left && x<=r.right && y>=r.top && y<=r.bottom;
}
/* ===== 확대 ===== */
function applyStageScale(next,anchor){
  next=clamp(next,MIN_SCALE,MAX_SCALE);
  const prev=scale;
  if(anchor){
    const r=container.getBoundingClientRect();
    const sx=container.scrollLeft+(anchor.clientX-r.left);
    const sy=container.scrollTop +(anchor.clientY-r.top);
    scale=next; applyStageSize();
    const ratio=scale/prev;
    container.scrollLeft=sx*ratio-(anchor.clientX-r.left);
    container.scrollTop =sy*ratio-(anchor.clientY-r.top);
  } else { scale=next; applyStageSize(); }
  zoomHud.textContent=Math.round(scale*100)+'%';
  saveState();
}
function resizeForegroundByFactor(f,anchor){
  if(!fgState.visible) return;
  let newW=clamp(fgState.w*f,20,baseW);
  let newH=clamp(fgState.h*f,20,baseH);
  const ax=clamp(anchor.lx,fgState.x,fgState.x+fgState.w);
  const ay=clamp(anchor.ly,fgState.y,fgState.y+fgState.h);
  const relX=(ax-fgState.x)/fgState.w, relY=(ay-fgState.y)/fgState.h;
  let newX=ax-relX*newW, newY=ay-relY*newH;
  newX=clamp(newX,0,baseW-newW); newY=clamp(newY,0,baseH-newH);
  fgState.x=newX; fgState.y=newY; fgState.w=newW; fgState.h=newH;
  syncFgVisual(); saveState();
}
/* ===== 전경 드래그 ===== */
let dragging=false, dragDX=0, dragDY=0;
function startFgDrag(x,y){
  if(!fgState.visible) return;
  dragging=true; const {lx,ly}=screenToLogical(x,y);
  dragDX=lx-fgState.x; dragDY=ly-fgState.y;
}
function moveFgDrag(x,y){
  if(!dragging) return;
  const {lx,ly}=screenToLogical(x,y);
  let nx=lx-dragDX, ny=ly-dragDY;
  nx=clamp(nx,0,baseW-fgState.w); ny=clamp(ny,0,baseH-fgState.h);
  fgState.x=nx; fgState.y=ny; syncFgVisual(); saveState();
}
function stopFgDrag(){ dragging=false; }
/* ===== 패닝 ===== */
let panning=false, panStartX=0, panStartY=0, panScrollX=0, panScrollY=0;
function startPan(x,y){ panning=true; panStartX=x; panStartY=y;
  panScrollX=container.scrollLeft; panScrollY=container.scrollTop;}
function movePan(x,y){ if(!panning) return;
  container.scrollLeft=panScrollX-(x-panStartX);
  container.scrollTop =panScrollY-(y-panStartY);}
function stopPan(){ panning=false; saveState(); }
/* ===== 전경 리사이즈 ===== */
let resizing=false;
function startResize(){ resizing=true; }
function moveResize(x,y){
  if(!resizing) return;
  const r=fg.getBoundingClientRect();
  let newW=(x-r.left)/scale, newH=(y-r.top)/scale;
  newW=clamp(newW,20,baseW-fgState.x); newH=clamp(newH,20,baseH-fgState.y);
  fgState.w=newW; fgState.h=newH; syncFgVisual(); saveState();
}
function stopResize(){ resizing=false; }
/* ===== 입력 ===== */
btnBg.onclick=()=>inputBg.click();
btnFg.onclick=()=>inputFg.click();
/* 추가: 전체화면(= 100%) 버튼 로직 */
btnFull.onclick=()=>{
  // 컨테이너 기준으로 이미지가 꽉 차도록 계산된 baseW/baseH를 재계산 후
  // 배율을 정확히 1로 맞추고 스크롤 초기화
  computeBaseSize();
  applyStageScale(1, null);
  container.scrollLeft = 0;
  container.scrollTop = 0;
  zoomHud.textContent = '100%';
  saveState();
};

inputBg.onchange=e=>{
  const f=e.target.files[0]; if(!f) return;
  bg.src=URL.createObjectURL(f);
  bg.onload=()=>{ computeBaseSize(); applyStageSize(); saveState(); };
};
inputFg.onchange=e=>{
  const f=e.target.files[0]; if(!f) return;
  fg.src=URL.createObjectURL(f);
  fg.onload=()=>{
    fgState.w=150; fgState.h=150;
    fgState.x=(baseW-150)/2; fgState.y=(baseH-150)/2;
    fgState.visible=true; syncFgVisual(); saveState();
  };
};
/* ===== 포인터/핀치 ===== */
const ptrs=new Map(); let lastDist=null;
container.addEventListener('pointerdown',e=>{
  container.setPointerCapture(e.pointerId);
  ptrs.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(e.target===fg) startFgDrag(e.clientX,e.clientY);
  else if(e.target===fgHandle) startResize();
  else startPan(e.clientX,e.clientY);
});
container.addEventListener('pointermove',e=>{
  if(!ptrs.has(e.pointerId)) return;
  ptrs.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(ptrs.size===2){
    const p=[...ptrs.values()];
    const dx=p[0].x-p[1].x, dy=p[0].y-p[1].y;
    const dist=Math.hypot(dx,dy);
    const cx=(p[0].x+p[1].x)/2, cy=(p[0].y+p[1].y)/2;
    if(lastDist){
      const ratio=dist/lastDist;
      const bothOnFg=p.every(pt=>pointInFg(pt.x,pt.y));
      if(bothOnFg) resizeForegroundByFactor(ratio,screenToLogical(cx,cy));
      else applyStageScale(scale*ratio,{clientX:cx,clientY:cy});
    }
    lastDist=dist; return;
  }
  if(dragging) moveFgDrag(e.clientX,e.clientY);
  else if(panning) movePan(e.clientX,e.clientY);
  else if(resizing) moveResize(e.clientX,e.clientY);
},{passive:false});
['pointerup','pointercancel','pointerleave'].forEach(t=>{
  container.addEventListener(t,e=>{
    ptrs.delete(e.pointerId); if(ptrs.size<2) lastDist=null;
    stopFgDrag(); stopPan(); stopResize();
  });
});
/* ===== 초기화 ===== */
window.addEventListener('load',()=>{
  computeBaseSize(); applyStageSize();
  restoreState();
});
window.addEventListener('resize',()=>{
  computeBaseSize(); applyStageSize();
  applyStageScale(scale,null);
});
</script>
</body>
</html>
